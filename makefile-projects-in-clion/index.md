# Как работать с `Makefile`-проектами в среде _CLion_

Основная проблема с проектами, использующими в качестве системы сборки _Make_,
состоит в том, что эта система сборки не предоставляет ровным счётом никакой
информации о проектной модели, т. е. о том, какие файлы исходного кода попадут
на вход компилятору, какие ключи компилятора, директивы препроцессора и
заголовочные файлы будут использованы, и какие бинарные файлы мы получим на
выходе. Эта информация остаётся неизвестной до тех пор, пока проект не будет
собран. В этом состоит сложность задачи интеграции сред разработки (IDE) и
системы сборки _Make_.

Рассмотрим, например, проект с вот такой плоской структурой:

```
Makefile
foo.c
bar.c
```

и вот таким элементарным `Makefile`:

```Makefile
.PHONY: all
all: foo

.PHONY: clean
clean:
	$(RM) foo
```

Здесь видно, что файл `foo.c` является частью проектной модели, т. к. будет
участвовать в процессе компиляции (посредством встроенного правила `$(CC) foo.c
-o foo`), а файл `bar.c` &mdash; не является.

## Подходы к анализу проектной модели

### База данных компиляции

Можно решить задачу "в лоб" и просто сначала собрать проект, а затем выяснить,
какие файлы и с какими флагами были скомпилированы. Для создания файла
`compile_commands.json` (собственно базы данных компиляции) будем использовать
любой из доступных генераторов &mdash;
[`bear`](https://github.com/rizsotto/Bear) или
[`compiledb`](https://github.com/nickdiego/compiledb). `bear` работает
посредством перехвата динамических вызовов (`LD_PRELOAD`) и потому выдаёт
достаточно точный результат, не зависит от системы сборки (т. е. может
использоваться совместно с любой системой сборки, хоть с чёртом в ступе, а не
только с _Make_), но имеет ограничения на _Mac OS X_ и вообще не работает на
_Windows_. С другой стороны, `compiledb` анализирует исключительно _вывод_
команды `make` и потому нередко совершает ошибки, но, с другой стороны,
работает везде. Если вы используете _Linux_, я предлагаю вам остановить свой
выбор именно на `bear`. По крайней мере, у вас не будет ошибок, связанных с
неверной интрепретаций двойных кавычек, апострофов и путей, содержащих пробелы.

Итак, мы собрали наш проект, "обернув" команду сборки и выполнив что-то вроде
`bear make` или `bear make all`, и теперь имеем на выходе заветный
`compile_commands.json`. _CLion_ вполне в состоянии открыть этот файл как
проект, но я вижу по меньшей мере 2 недостатка:

 1. Сборка всего проекта может занимать десятки минут (ядро _Linux_) или даже
    часы, а открыть проект в IDE хочется "почти мгновенно".

 1. Если вы не просто открыли проект с целью "посмотреть код", а собираетесь
    добавлять/удалять/переименовывать файлы, переписывать сам `Makefile` или
    его прототип (как в системах сборки типа [_GNU
    Autotools_](https://ru.wikipedia.org/wiki/Autotools), работающих поверх
    _Make_), то после каждой такой операции вам придётся заново генерировать
    базу данных компиляции. И это муторно, скажу я вам.

Поэтому стоит задаться вопросом, нет ли способа проанализировать структуру
проекта, не выполняя сборку.

### Запуск _Make_ в режиме "dry run"

На русский язык переводится как "репетиция", но я ни разу не слышал, чтобы
использовался русскоязычный термин, поэтому впредь буду называть этот режим
именно "dry run", как в англоязычной документации. Вот описание ключа командной
строки _GNU Make_:

>       -n, --just-print, --dry-run, --recon
>            Print the commands that would be executed, but do not execute them
>            (except in certain circumstances).

## Выделение списка целей

### _GNU Make_

### _BSD Make_

## Рекомендации
