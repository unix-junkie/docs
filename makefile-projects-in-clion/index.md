# Как работать с `Makefile`-проектами в среде _CLion_

## Содержание

 * [Постановка задачи](#постановка-задачи)
 * [Подходы к анализу проектной модели](#подходы-к-анализу-проектной-модели)
 * [Выделение списка целей](#выделение-списка-целей)
 * [Рекомендации](#рекомендации)

Если вам лень вникать в скучные технические детали, можете перейти прямо к
разделу "[Рекомендации](#рекомендации)".

## Постановка задачи

Основная проблема с проектами, использующими в качестве системы сборки _Make_,
состоит в том, что эта система сборки не предоставляет ровным счётом никакой
информации о проектной модели, т. е. о том, какие файлы исходного кода попадут
на вход компилятору, какие ключи компилятора, директивы препроцессора и
заголовочные файлы будут использованы, и какие бинарные файлы мы получим на
выходе. Эта информация остаётся неизвестной до тех пор, пока проект не будет
собран. В этом состоит сложность задачи интеграции сред разработки (IDE) и
системы сборки _Make_.

Рассмотрим, например, проект с вот такой плоской структурой:

```
Makefile
foo.c
bar.c
```

и вот таким элементарным `Makefile`:

```Makefile
.PHONY: all
all: foo

.PHONY: clean
clean:
	$(RM) foo
```

Здесь видно, что файл `foo.c` является частью проектной модели, т. к. будет
участвовать в процессе компиляции (посредством встроенного правила `$(CC) foo.c
-o foo`), а файл `bar.c` &mdash; не является.

## Подходы к анализу проектной модели

### База данных компиляции

Можно решить задачу "в лоб" и просто сначала собрать проект, а затем выяснить,
какие файлы и с какими флагами были скомпилированы. Для создания файла
`compile_commands.json` (собственно базы данных компиляции) будем использовать
любой из доступных генераторов &mdash;
[`bear`](https://github.com/rizsotto/Bear) или
[`compiledb`](https://github.com/nickdiego/compiledb). `bear` работает
посредством перехвата динамических вызовов (`LD_PRELOAD`) и потому выдаёт
достаточно точный результат, не зависит от системы сборки (т. е. может
использоваться совместно с любой системой сборки, хоть с чёртом в ступе, а не
только с _Make_), но имеет ограничения на _Mac OS X_ и вообще не работает на
_Windows_. С другой стороны, `compiledb` анализирует исключительно _вывод_
команды `make` и потому нередко совершает ошибки, но, с другой стороны,
работает везде. Если вы используете _Linux_, я предлагаю вам остановить свой
выбор именно на `bear`. По крайней мере, у вас не будет ошибок, связанных с
неверной интерпретацией двойных кавычек, апострофов и путей, содержащих пробелы.

Итак, мы собрали наш проект, "обернув" команду сборки и выполнив что-то вроде
`bear make` или `bear make all`, и теперь имеем на выходе заветный
`compile_commands.json`. _CLion_ вполне в состоянии открыть этот файл как
проект, но я вижу по меньшей мере 2 недостатка:

 1. Сборка всего проекта может занимать десятки минут (ядро _Linux_) или даже
    часы, а открыть проект в IDE хочется "почти мгновенно".

 1. Если вы не просто открыли проект с целью "посмотреть код", а собираетесь
    добавлять/удалять/переименовывать файлы, переписывать сам `Makefile` или
    его прототип (как в системах сборки типа [_GNU
    Autotools_](https://ru.wikipedia.org/wiki/Autotools), работающих поверх
    _Make_), то после каждой такой операции вам придётся заново генерировать
    базу данных компиляции. И это муторно, скажу я вам.

Поэтому стоит задаться вопросом, нет ли способа проанализировать структуру
проекта, не выполняя сборку.

### Запуск _Make_ в режиме "dry run"

На русский язык переводится как "репетиция", но я ни разу не слышал, чтобы
использовался русскоязычный термин, поэтому впредь буду называть этот режим
именно "dry run", как в англоязычной документации. Вот описание ключа командной
строки _GNU Make_:

>       -n, --just-print, --dry-run, --recon
>            Print the commands that would be executed, but do not execute them
>            (except in certain circumstances).

## Выделение списка целей

### _GNU Make_

### _BSD Make_

## Рекомендации

Теперь, собственно, то, ради чего вся эта статья и была написана. Следование
этим рекомендациям не даст стопроцентной гарантии, что ваш проект без ошибок
откроется в CLion, но, во всяком случае, существенно снизит количество этих
ошибок.

 1. Убедитесь, что проект таки собирается (в том же окружении и тем же
    компилятором, какие выбраны в настройках проекта _CLion_). Условно говоря,
    если в настройках выбраны WSL и GCC, то код должен собираться в выбранной
    гостевой виртуальной машине компилятором GCC. Отсутствующие заголовочные
    файлы, недостающие зависимости, завершающийся с ошибкой сценарий
    `configure` (для _GNU Autotools_) &mdash; все эти проблемы стоит разрешить
    заранее, _до_ того, как вы попытаетесть открыть проект в _CLion_.

 1. Используйте [_GNU Make_](https://www.gnu.org/software/make/). Убедитесь,
    что путь именно к этому инструменту выбран у вас в настройках. [_POSIX
    Make_](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html),
    [_BSD Make_](https://www.crufty.net/help/sjg/bmake.html), [_Borland
    Make_](http://docs.embarcadero.com/products/rad_studio/radstudio2007/RS2007_helpupdates/HUpdate4/EN/html/devwin32/make_xml.html)
    и [_Microsoft NMake_](https://docs.microsoft.com/en-us/cpp/build/reference/nmake-reference)
    пока не поддерживаются.

 1. Избегайте параллелизма на уровне процессов (`make -jN` при _N > 1_),
    "зашитого" в `Makefile` через переопределение переменных `MFLAGS`,
    `MAKEFLAGS` или `GNUMAKEFLAGS` (подробнее в [5.7.3 Communicating Options to
    a Sub-`make`](https://www.gnu.org/software/make/manual/html_node/Options_002fRecursion.html)):

    ```Makefile
    MAKEFLAGS += j8

    .PHONY: all
    all: foo-all bar-all

    .PHONY: foo-all
    foo-all:
    	$(MAKE) -C foo all

    .PHONY: bar-all
    bar-all:
    	$(MAKE) -C bar all
    ```

    В таких условиях _Make_ будет использовать более одного (в примере выше
    &mdash; 8) параллельного процесса при рекурсивных вызовах, в результате
    чего в выводе команды сообщения вида "Entering directory '...'" и "Leaving
    directory '...'" будут перемешаны между собой, команды компиляции &mdash;
    произвольным образом разбросаны между этими сообщениями, и _CLion_ не
    сможет отследить ни смену каталога, ни принадлежность команды тому или
    иному каталогу:

    ```
    make: Entering directory '/home/alice'
    make -C foo all
    make -C bar all
    make[1]: Entering directory '/home/alice/foo'
    make[1]: Entering directory '/home/alice/bar'
    echo "Making all in foo..."
    make[1]: Leaving directory '/home/alice/foo'
    echo "Making all in bar..."
    make[1]: Leaving directory '/home/alice/bar'
    make: Leaving directory '/home/alice'
    ```

 1. Аналогичным образом, при рекурсивных вызовах _Make_, не переопределяйте
    региональные настройки (`LC_*`, `LANG`, `LANGUAGE`) внутри ваших
    `Makefile`'ов и/или сценариев сборки. Дело в том, что _CLion_, отслеживая
    сообщения о смене каталога, ожидает эти сообщения именно на английском
    языке (и заботливо устанавливает нужное окружение для родительского
    процесса _Make_). Вот что будет, если вмешается пользователь:

    ```Makefile
    export LC_ALL = ru_RU.UTF-8
    export LANG = ru_RU.UTF-8

    .PHONY: all
    all: foo-all bar-all

    .PHONY: foo-all
    foo-all:
    	$(MAKE) -C foo all

    .PHONY: bar-all
    bar-all:
    	$(MAKE) -C bar all
    ```

    Вывод команды `make -wnk`:

    ```
    make: Entering directory '/home/alice'
    make -C foo all
    make[1]: вход в каталог «/home/alice/foo»
    echo "Making all in foo..."
    make[1]: выход из каталога «/home/alice/foo»
    make -C bar all
    make[1]: вход в каталог «/home/alice/bar»
    echo "Making all in bar..."
    make[1]: выход из каталога «/home/alice/bar»
    make: Leaving directory '/home/alice'
    ```
